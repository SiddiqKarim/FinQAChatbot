# **Chat Bot Start**

# Libraries
import streamlit as st
from sklearn.metrics.pairwise import cosine_similarity
from nltk.corpus import stopwords
import nltk
import re
import nltk
nltk.download('stopwords')
stopwords = nltk.corpus.stopwords.words('english')

import torch
import spacy
import subprocess
import numpy as np
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
import io
import base64
from datetime import datetime

# Load SpaCy English language model
try:
    nlp = spacy.load("en_core_web_sm")
except OSError:
    subprocess.call(["python", "-m", "spacy", "download", "en_core_web_sm"])
    nlp = spacy.load("en_core_web_sm")


# Load SpaCy English language model
nlp = spacy.load("en_core_web_sm")


# Import necessary files

df = pd.read_csv("Financial1.csv")
df_mp = pd.read_csv("qa1.csv")
qa_data = ""

# pre Process the data

def preprocess_text(text):
    doc = nlp(text)
    lemmas = [token.lemma_ for token in doc]
    lemmas_without_stopwords = [lemma for lemma in lemmas if lemma.lower() not in stopwords and lemma.isalpha()]

    return ' '.join(lemmas_without_stopwords)

# Loading the dataset

def load_database(numbers_to_text=True):
    
    #if numbers_to_text:
    #    df_mp['question'] = df_mp['question'].apply(transcribe_numbers)

    df_mp['processed_texts'] = df_mp['question'].apply(preprocess_text)    
    qa_data = qa_data['processed_texts'].tolist()

# Cosine Similarity
from scipy.spatial.distance import cosine
import difflib
from sklearn.feature_extraction.text import CountVectorizer
def Cosine_distance(user_question, numbers_to_text=True):
    df_mp['processed_texts'] = df_mp['question'].apply(preprocess_text)
    qa_data = df_mp['processed_texts'].tolist()
    
    if numbers_to_text:
        user_question = preprocess_text(user_question)
                                         
    user_text_processed = preprocess_text(user_question)
    vectorizer = TfidfVectorizer()
    bow_matrix = vectorizer.fit_transform(qa_data + [user_text_processed])

    cosine_distances = cosine_similarity(bow_matrix[-1], bow_matrix[:-1])
   
    max_distance_index = cosine_distances.argmax()
     
    df_mp['distances'] = cosine_distances.flatten().tolist()

    return df_mp['question'].iloc[max_distance_index], df_mp['location'].iloc[max_distance_index],  df_mp['intent'].iloc[max_distance_index]
        

# Fuunction calling to get a numerical data for company


def fun_detail(company_name, year_name, intent):
    # code if someone not provide Company name:
    print(company_name)
    if not company_name:
        return "Can you please provide your query with the company name?"    
    if not year_name:
        return "Can you please provide your query with the year?"
    
    # Filter the DataFrame based on the company name
    filtered_df = df[df['Company'].str.upper() == company_name[0]]
    print(filtered_df)
    company_name_str = ', '.join([name.title() for name in company_name])
    # Check if the company name is in the dataset
    if filtered_df.empty:
        company_name_str = ', '.join([name.title() for name in company_name])
        return f"The {company_name_str} company is not available in our database. You have to select from our company list."
    
    # Check if year_name is a list
    if isinstance(year_name, list):
        # Check each year in the list
        result = []
        for year in year_name:
            if int(year) < df['Year'].min() or int(year) > df['Year'].max():
                result.append(f"The {company_name_str} company financial report is just available between {df['Year'].min()} to {df['Year'].max()} as the provided year {year} is not in our database.")
            else:
                filtered_df_year = filtered_df[filtered_df['Year'] == int(year)]
                if filtered_df_year.empty:
                    result.append(f"No data available for {company_name_str} in {year}.")
                else:
                    print("class", intent)
                    if intent in ["Revenue"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is Revanue
                        result.append(f"In {year}, {company_name_str} reported a revenue of ${str(value_detail)} millions. This figure represents the total income generated by {company_name_str} from its various business activities during that year.")
                    elif intent in ["Gross Profit"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is Gross Profit
                        result.append(f"In {year}, {company_name_str}'s gross profit was ${str(value_detail)} millions. This figure represents the total revenue minus the cost of goods sold, indicating the amount of money {company_name_str} earned from its core business activities.")
                    elif intent in ["Market Cap"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is Market capitalization
                        result.append(f"In {year}, {company_name_str}'s market capitalization was ${str(value_detail)} millions. Market capitalization, or market cap, is the total value of a company's outstanding shares of stock, calculated by multiplying the current stock price by the total number of outstanding shares.")
                    elif intent in ["Net Income"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is Net Income
                        result.append(f"In {year}, {company_name_str}'s net income was ${str(value_detail)} millions. Net income is the total amount of profit a company earns after subtracting all expenses from its total revenue.")
                    elif intent in ["Earning Per Share"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is Net Income
                        result.append(f"In {year}, {company_name_str}'s Earnings Per Share (EPS) was ${str(value_detail)}. EPS is a financial metric that represents the portion of a company's profit allocated to each outstanding share of common stock. It is calculated by dividing the company's net income by the total number of outstanding shares. A higher EPS indicates that a company is more profitable on a per-share basis, while a lower EPS suggests lower profitability per share.")
                    elif intent in ["EBITDA"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is EBITDA
                        result.append(f"In {year}, {company_name_str}'s EBITDA was ${str(value_detail)} millions. EBITDA stands for Earnings Before Interest, Taxes, Depreciation, and Amortization, and it is a measure of a company's operating performance.")
                    elif intent in ["Share Holder Equity"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is share holder Euaity
                        result.append(f"In {year}, {company_name_str}'s shareholder equity was ${str(value_detail)} millions. Shareholder equity represents the amount of company assets that are financed by shareholders' investments and retained earnings.")
                    elif intent in ["Cash Flow from Operating"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is Cash flow from operating 
                        result.append(f"In {year}, {company_name_str}'s cash flow from operating activities was ${str(value_detail)} millions. This figure represents the cash generated or used by {company_name_str}'s normal business operations, such as selling products and services, and is a key indicator of the company's financial health.")
                    elif intent in ["Cash Flow from Investing"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is cash flow from Investing
                        result.append(f"In {year}, {company_name_str}'s cash flow from investing activities was ${str(value_detail)} millions. This means that {company_name_str} spent ${str(value_detail)} millions on investing activities such as purchasing property, plant, and equipment, acquiring other companies, or making investments, which exceeded the cash inflows from these activities.")
                    elif intent in [ "Cash Flow from Financial Activities"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is cash floe from financial Activities
                        result.append(f"In {year}, {company_name_str}'s cash flow from financial activities was ${str(value_detail)} millions. This indicates that during that year, {company_name_str} had a net outflow of cash related to its financial activities, which can include things like issuing or repurchasing stock, paying dividends, or taking out loans. A negative value suggests that {company_name_str} spent more on financial activities than it received.")
                    elif intent in [ "Current Ratio"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is cash floe from current Ratio
                        result.append(f"In {year}, {company_name_str}'s current ratio was {str(value_detail)}. The current ratio is a liquidity ratio that measures a company's ability to cover its short-term liabilities with its short-term assets. A current ratio below 1 indicates that a company may have difficulty meeting its short-term obligations with its current assets alone. On the other hand, a current ratio above 1 suggests that a company has more current assets than current liabilities, which generally indicates a healthier financial position to meet short-term obligations.")
                    elif intent in [ "Debtor Equity Ratio"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is cash floe from Debtor Equity Ratio
                        result.append(f"The Debt-to-Equity (DE) ratio for {company_name_str} in {year} was {str(value_detail)}. This ratio is calculated by dividing a company's total liabilities by its shareholder equity. A lower debt-to-equity (DE) ratio indicates better financial health and lower risk, while a higher ratio suggests increased financial risk due to greater reliance on debt financing.")
                    elif intent in ["ROE"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is the ROE
                        result.append(f"In {year}, {company_name_str}'s return on equity (ROE) was approximately {str(value_detail)}%. ROE is a financial metric that measures a company's profitability relative to its shareholder equity. A higher return on equity (ROE) indicates that a company is more efficient at generating profits from its equity. Conversely, a lower ROE suggests lower efficiency in generating profits from equity.")
                    elif intent in ["ROA"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is the ROA
                        result.append(f"In {year}, {company_name_str}'s Return on Assets (ROA) was {str(value_detail)}%. ROA measures how efficiently a company uses its assets to generate profit. A higher return on assets (ROA) indicates that the company is more effective in using its assets to generate earnings. Conversely, a lower ROA suggests less efficiency in using assets to generate earnings.")
                    elif intent in ["ROI"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is ROI
                        result.append(f"In {year}, {company_name_str}'s return on investment (ROI) was {str(value_detail)}. ROI is a financial metric used to evaluate the efficiency or profitability of an investment. It is calculated by dividing the net profit from the investment by the initial cost of the investment, and then multiplying by 100 to express it as a percentage. A higher return on investment (ROI) indicates a more profitable investment. On the Other hand, a lower ROI suggests a less profitable investment.")
                    elif intent in ["Return on Tangible Equity"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is the Return on Tangible Equity
                        result.append(f"In {year}, {company_name_str}'s Return on Tangible Equity (RoTE) was approximately {str(value_detail)}%. RoTE is a financial metric that measures a company's profitability in relation to its tangible equity, which excludes intangible assets. A higher return on tangible equity (RoTE) indicates that a company is generating more profit from its tangible assets, which is favorable for investors. On the contrary, a lower RoTE suggests that the company may not be utilizing its tangible assets as efficiently to generate profits.")
                    elif intent in [ "Net Profit Margin"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is the Net Profit Margin
                        result.append(f"In {year}, {company_name_str}'s net profit margin was {str(value_detail)}%. Net profit margin is a profitability ratio that measures how much of every dollar of revenue a company actually keeps in earnings after accounting for all expenses. A higher net profit margin indicates that a company is more efficient at generating profits from its revenue, while a lower net profit margin suggests that a company may be less efficient at generating profits from its revenue.")
                    elif intent in ["Free Cash Flow pe Share"]:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is the Free Cash Flow pe Share
                        result.append(f"In {year}, {company_name_str}'s Free Cash Flow per Share was ${str(value_detail)}. Free Cash Flow per Share is a measure of the amount of cash a company generates per share of its stock, after accounting for capital expenditures. It indicates the cash available to shareholders after all expenses and investments have been paid for.")
                    else:
                        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'intent' is the column name
                        result.append(str(value_detail))

        return result[0] if len(result) == 1 else result  # Return single result or list of results
    
    else:
        # Check if any data is available after filtering
        
        if int(year_name) < df['Year'].min() or int(year_name) > df['Year'].max():
            return f"The {company_name_str} company financial report is just available between {df['Year'].min()} to {df['Year'].max()} as the provided year {year_name} is not in our database."
        
        filtered_df_year = filtered_df[filtered_df['Year'] == int(year_name)]
        if filtered_df_year.empty:
            return f"No data available for {company_name_str} in {year_name}."
        # Extract the revenue value
        value_detail = float(filtered_df_year[intent].iloc[0])  # Assuming 'Revenue' is the column name
        return str(value_detail)  # Convert value_detail to string

    
    
    
# Linear Function to Predict the Future Values
def linear_regression_and_plot(intent, company_name):
    
    # Filter the DataFrame based on the company name
    filtered_df = df[df['Company'].str.upper() == company_name[0]]
    
    company_name_str = ', '.join([name.title() for name in company_name])
    # Extract data for the specific financial term and company
    X = filtered_df["Year"].values
    y = filtered_df[intent].values
    
    # Train linear regression model
    model = LinearRegression()
    model.fit(X.reshape(-1, 1), y)

    # Predict values for the next 5 years
    future_years = np.arange(X.max() + 1, X.max() + 6).reshape(-1, 1)
    predicted_values = model.predict(future_years)

    # Print all the available data for the financial term
    #print(f"{intent} Data:")
    #for year, value in zip(X, y):
     #   print(f"Year: {year}, {intent}: {value}")

    # Plot the linear regression
    plt.figure(figsize=(10, 6))
    plt.scatter(filtered_df["Year"], filtered_df[intent], color='blue', label='Actual Data')
    plt.plot(future_years, predicted_values, color='red', label='Linear Regression')
    plt.xlabel('Year')
    plt.ylabel(intent)
    plt.title(f'prediction for {intent} {company_name_str}')
    plt.legend()
    plt.show()

    # Convert the plot to an image
    fig, ax = plt.subplots()
    ax.scatter(filtered_df["Year"], filtered_df[intent], color='blue', label='Actual Data')
    ax.plot(future_years, predicted_values, color='red', label='Linear Regression')
    #ax.plot(future_years, predicted_values)
    ax.set_xlabel('Year')
    ax.set_ylabel(intent)
    ax.set_title(f'Prediction for {intent} {company_name[0]}')
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    # Encode the image as a base64 string
    image_base64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close(fig)
    return future_years, predicted_values, image_base64

# Compare the companies with specific details

def comparative_analysis(company_name, intent):
    
    # Initialize lists to store data for each company
    company_years = {}
    company_values = {}
    # Fetch data for each company and financial term
    
    for company in company_name:
        # Filter data for the specific company and financial term
        company_data = df[df['Company'].str.upper() == company]
        #company_data = df[df['Company'] == company]
        
        company_years[company] = company_data['Year'].values
        company_values[company] = company_data[intent].values

      # Plot the comparative analysis
    plt.figure(figsize=(10, 6))
    for company in company_name:
        
        plt.plot(company_years[company], company_values[company], label=company)

    # Add labels and title
    plt.xlabel('Year')
    plt.ylabel(intent)
    plt.title(f'Comparative Analysis of {intent} across Companies')

    # Add legend
    plt.legend()

    # Show the plot
    plt.grid(True)
    plt.show()

    # Convert the plot to an image
    fig, ax = plt.subplots(figsize=(10, 6))
    for company in company_name:
        ax.plot(company_years[company], company_values[company], label=company)
    ax.set_xlabel('Year')
    ax.set_ylabel(intent)
    ax.set_title(f'Comparative Analysis of {intent} across Companies')
    ax.legend()
    ax.grid(True)  # Add grid
    plt.tight_layout()  # Adjust layout
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    # Encode the image as a base64 string
    image_base64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close(fig)
    result = f"This graph provides a comparative analysis of {intent} across different companies, allowing for a visual comparison of performance or metrics over time or between companies. Each line represents a different company, showing how {intent} has changed over the specified period. All the financial terms are in Millions of USD other than the ratios"
    return image_base64, result

    
# srock evaluaiton:
def stock_valuation(company_name, year_name):
    # code if someone not provide Company name:
    if not company_name:
        return "Can you please provide your query with the company name?"    
    if not year_name:
        return "Can you please provide your query with the year?"
    
    # Filter the DataFrame based on the company name
    filtered_df = df[df['Company'].str.upper() == company_name[0]]
    
    company_name_str = ', '.join([name.title() for name in company_name])
    # Check if the company name is in the dataset
    if filtered_df.empty:
        return f"The {company_name_str} company is not available in our database. You have to select from our company list."
    
    # Check if year_name is a list
    if isinstance(year_name, list):
        # Check each year in the list
        result = []
        for year in year_name:
            if int(year) < df['Year'].min() or int(year) > df['Year'].max():
                result.append(f"The {company_name_str} company financial report is just available between {df['Year'].min()} to {df['Year'].max()} as the provided year {year} is not in our database.")
            else:
                filtered_df_year = filtered_df[filtered_df['Year'] == int(year)]
                if filtered_df_year.empty:
                    result.append(f"No data available for {company_name_str} in {year}.")
                else:
                    # Filter data for the specified company and year
                    company_data = df[(df['Company'].str.upper() == company_name[0]) & (df['Year'] == int(year_name[0]))].copy()
    
                    # Calculate P/E ratio
                    company_data.loc[:, 'PE_ratio'] = company_data['Market Cap'] / company_data['Earning Per Share']

                    # Calculate stock price based on P/E ratio
                    company_data.loc[:, 'Stock Price PE'] = company_data['Earning Per Share'] * company_data['PE_ratio']

                    # Calculate stock price based on FCF per Share (assuming a growth rate of 5%)
                    growth_rate = 0.05
                    company_data.loc[:, 'Stock Price FCF'] = company_data['Free Cash Flow per Share'] * (1 + growth_rate)

                    # Explanation for P/E Ratio
                    pe_ratio_explanation = f"The Price-to-Earnings (P/E) ratio of {company_name[0]} for the year {year_name[0]} is {company_data['PE_ratio'].values[0]}. This means that investors are willing to pay a certain multiple of the company's earnings per share, which indicates their expectation for future earnings growth. A higher P/E ratio suggests that investors are more optimistic about the company's future prospects."

                    # Explanation for FCF per Share
                    fcf_per_share_explanation = f"The Free Cash Flow (FCF) per Share of {company_name[0]} for the year {year_name[0]} is {company_data['Free Cash Flow per Share'].values[0]}. This represents the amount of cash generated by the company for each share of common stock outstanding. A higher FCF per share indicates that the company has more cash available for potential investments, debt reduction, or distributions to shareholders."
                    result.extend(["Stock Valuation Results:",pe_ratio_explanation, fcf_per_share_explanation])
        return "\n".join(result)  # Return single result or list of results

    else:
        # Check if any data is available after filtering
        if int(year_name) < df['Year'].min() or int(year_name) > df['Year'].max():
            return f"The {company_name_str} company financial report is just available between {df['Year'].min()} to {df['Year'].max()} as the provided year {year_name} is not in our database."
        
        filtered_df_year = filtered_df[filtered_df['Year'] == int(year_name)]
        if filtered_df_year.empty:
            return f"No data available for {company_name_str} in {year_name}."
        # Extract the revenue value
        company_data = df[(df['Company'].str.upper() == company_name[0]) & (df['Year'] == int(year_name))].copy()
    
        # Calculate P/E ratio
        company_data.loc[:, 'PE_ratio'] = company_data['Market Cap'] / company_data['Earning Per Share']

        # Calculate stock price based on P/E ratio
        company_data.loc[:, 'Stock Price PE'] = company_data['Earning Per Share'] * company_data['PE_ratio']

        # Calculate stock price based on FCF per Share (assuming a growth rate of 5%)
        growth_rate = 0.05
        company_data.loc[:, 'Stock Price FCF'] = company_data['Free Cash Flow per Share'] * (1 + growth_rate)

        # Explanation for P/E Ratio
        pe_ratio_explanation = f"The Price-to-Earnings (P/E) ratio of {company_name[0]} for the year {year_name[0]} is {company_data['PE_ratio'].values[0]}. This means that investors are willing to pay a certain multiple of the company's earnings per share, which indicates their expectation for future earnings growth. A higher P/E ratio suggests that investors are more optimistic about the company's future prospects."

        # Explanation for FCF per Share
        fcf_per_share_explanation = f"The Free Cash Flow (FCF) per Share of {company_name[0]} for the year {year_name[0]} is {company_data['Free Cash Flow per Share'].values[0]}. This represents the amount of cash generated by the company for each share of common stock outstanding. A higher FCF per share indicates that the company has more cash available for potential investments, debt reduction, or distributions to shareholders."
        
        return "\n".join(["Stock Valuation Results:",pe_ratio_explanation, fcf_per_share_explanation])

    
# srock evaluaiton:
def financial_risk_assessment(company_name, year_name):
    # code if someone not provide Company name:
    if not company_name:
        return "Can you please provide your query with the company name?"    
    if not year_name:
        return "Can you please provide your query with the year?"
    
    # Filter the DataFrame based on the company name
    filtered_df = df[df['Company'].str.upper() == company_name[0]]
    
    company_name_str = ', '.join([name.title() for name in company_name])
    # Check if the company name is in the dataset
    if filtered_df.empty:
        return f"The {company_name_str} company is not available in our database. You have to select from our company list."
    
    # Check if year_name is a list
    if isinstance(year_name, list):
        # Check each year in the list
        result = []
        for year in year_name:
            if int(year) < df['Year'].min() or int(year) > df['Year'].max():
                result.append(f"The {company_name_str} company financial report is just available between {df['Year'].min()} to {df['Year'].max()} as the provided year {year} is not in our database.")
            else:
                filtered_df_year = filtered_df[filtered_df['Year'] == int(year)]
                if filtered_df_year.empty:
                    result.append(f"No data available for {company_name_str} in {year}.")
                else:
                    # Filter data for the specified company and year
                    # Filter data for the specified company and year
                    company_data = df[(df['Company'].str.upper() == company_name[0]) & (df['Year'] == int(year_name[0]))].copy()
                    # Calculate Net Profit Margin
                    
                    net_profit_margin = company_data['Net Profit Margin'].values[0]

                    # Calculate Debtor Equity Ratio
                    debtor_equity_ratio = company_data['Debtor Equity Ratio'].values[0]

                    # Calculate Return on Tangible Equity
                    rote = company_data['Return on Tangible Equity'].values[0]

                    # Explanation for Net Profit Margin
                    net_profit_margin_explanation = f" Financial Risk Assessment Results: Net Profit Margin: The Net Profit Margin of {company_name_str} for the year {year_name} is {net_profit_margin:.2f}%. This metric indicates the percentage of revenue that remains as net income after all expenses have been deducted. A higher net profit margin suggests better profitability and financial health."

                    # Explanation for Debtor Equity Ratio
                    debtor_equity_ratio_explanation = f"Debtor Equity Ratio: The Debtor Equity Ratio of {company_name_str} for the year {year_name} is {debtor_equity_ratio:.2f}. This ratio measures the relationship between a company's total debt and its shareholder equity. A higher debtor equity ratio indicates higher financial leverage, which can increase financial risk."

                    # Explanation for Return on Tangible Equity
                    rote_explanation = f" Return on Tangible Equity:The Return on Tangible Equity (ROTE) of {company_name_str} for the year {year_name} is {rote:.2f}%. This metric assesses a company's profitability relative to its tangible equity capital. A higher ROTE indicates better efficiency in generating returns for shareholders."

                    # Combine all explanations into a single formatted string
                    
                    result.extend(["Financial Risk Assessment Results:",net_profit_margin_explanation, debtor_equity_ratio_explanation,rote_explanation])
        return "\n".join(result)  # Return single result or list of results

    else:
        # Check if any data is available after filtering
        if int(year_name) < df['Year'].min() or int(year_name) > df['Year'].max():
            return f"The {company_name_str} company financial report is just available between {df['Year'].min()} to {df['Year'].max()} as the provided year {year_name} is not in our database."
        
        filtered_df_year = filtered_df[filtered_df['Year'] == int(year_name)]
        if filtered_df_year.empty:
            return f"No data available for {company_name_str} in {year_name}."
        # Extract the revenue value
        company_data = df[(df['Company'].str.upper() == company_name[0]) & (df['Year'] == int(year_name))].copy()
        # Calculate Net Profit Margin
        net_profit_margin = company_data['Net Profit Margin'].values[0]

        # Calculate Debtor Equity Ratio
        debtor_equity_ratio = company_data['Debtor Equity Ratio'].values[0]

        # Calculate Return on Tangible Equity
        rote = company_data['Return on Tangible Equity'].values[0]

        # Explanation for Net Profit Margin
        net_profit_margin_explanation = f" Financial Risk Assessment Results: Net Profit Margin: The Net Profit Margin of {company_name_str} for the year {year_name} is {net_profit_margin:.2f}%. This metric indicates the percentage of revenue that remains as net income after all expenses have been deducted. A higher net profit margin suggests better profitability and financial health."

        # Explanation for Debtor Equity Ratio
        debtor_equity_ratio_explanation = f"Debtor Equity Ratio: The Debtor Equity Ratio of {company_name_str} for the year {year_name} is {debtor_equity_ratio:.2f}. This ratio measures the relationship between a company's total debt and its shareholder equity. A higher debtor equity ratio indicates higher financial leverage, which can increase financial risk."

        # Explanation for Return on Tangible Equity
        pr_rote_explanation = f" Return on Tangible Equity:The Return on Tangible Equity (ROTE) of {company_name_str} for the year {year_name} is {rote:.2f}%. This metric assesses a company's profitability relative to its tangible equity capital. A higher ROTE indicates better efficiency in generating returns for shareholders."

        # Combine all explanations into a single formatted string
        result = "\n".join(["Financial Risk Assessment Results:",net_profit_margin_explanation, debtor_equity_ratio_explanation, rote_explanation])
        
        return "\n".join(["Stock Valuation Results:",net_profit_margin_explanation, debtor_equity_ratio_explanation,rote_explanation])

    
# Capital budgeting
# Function to perform capital budgeting analysis
def perform_capital_budgeting_analysis(company_name, year_names):
    discount_rate = 0.08  # Replace with the appropriate discount rate

    # Function to calculate NPV
    def calculate_npv(cash_flows, discount_rate):
        npv = 0
        for t, cash_flow in enumerate(cash_flows):
            npv += cash_flow / ((1 + discount_rate) ** (t + 1))
        return npv

    # Function to calculate IRR
    def calculate_irr(cash_flows, iterations=1000):
        investment = cash_flows[0]
        for r in range(1, iterations):
            irr = (1 + r / 100.0)
            npv = 0
            for t, cash_flow in enumerate(cash_flows):
                npv += cash_flow / (irr ** (t + 1))
            if npv - investment <= 0:
                return round(irr - 1, 5)
        return None
    result = []
    # Filter data for the specified company and year
    for year_name in year_names:
        company_data = df[(df['Company'].str.upper() == company_name[0]) & (df['Year'] == int(year_name))].copy()
        
        # Check if the company exists in the dataset for the specified year
        if company_data.empty:
            result.append(f"Data not found for {company_name} in {year_name}.")
        else:
            # Calculate Free Cash Flow (FCF) for the current company and year
            company_data['FCF'] = company_data['Cash Flow from Operating'] - company_data['Cash Flow from Investing']

            # Calculate Net Present Value (NPV)
            cash_flows = [company_data['Cash Flow from Operating'].iloc[0], 
                          -company_data['Cash Flow from Investing'].iloc[0], 
                          -company_data['Cash Flow from Financial Activities'].iloc[0]]
            npv_value = calculate_npv(cash_flows, discount_rate)

            # Calculate Internal Rate of Return (IRR)
            irr_value = calculate_irr(cash_flows)

            # Calculate Payback Period
            cumulative_cash_flows = np.cumsum(cash_flows)
            payback_period = np.argmax(cumulative_cash_flows >= 0) + 1

            # Add the results to the result list
            result.append(f"\nResults of Capital Budgeting Analysis for {company_name[0]} in year {year_name}:\n"
                          f"NPV: {npv_value}\nIRR: {irr_value if irr_value is not None else 'IRR not found'}\n"
                          f"Payback Period: {payback_period} year")
    return "\n".join(result)

# SHould I Invest

# Define a function to determine if investing in a company is advisable based on certain criteria

def should_invest(company_name):
    # Initialize reasons for the decision
    reasons = []
    if not company_name:
        return "Can you please provide your query with the company name?"
    
    company_data = df[df['Company'].str.upper() == company_name[0].upper()]

    if company_data.empty:
        reasons.append("Data not found for the company in our dataset. Please provide a correct company name.")
        return "\n".join(reasons)
    
    row = company_data.iloc[0]

    if row['ROE'] > 0:
        reasons.append("Positive ROE")
    else:
        reasons.append("Negative ROE")

    if row['ROA'] > 0:
        reasons.append("Positive ROA")
    else:
        reasons.append("Negative ROA")

    if row['Net Profit Margin'] > 0.1:
        reasons.append("Net Profit Margin > 10%")
    else:
        reasons.append("Net Profit Margin <= 10%")

    if row['Current Ratio'] > 1.5:
        reasons.append("Current Ratio > 1.5")
    else:
        reasons.append("Current Ratio <= 1.5")

    if row['Free Cash Flow per Share'] > 0:
        reasons.append("Positive Free Cash Flow per Share")
    else:
        reasons.append("Negative Free Cash Flow per Share")

    positive_criteria = sum([1 for x in [row['ROE'], row['ROA'], row['Net Profit Margin'], row['Current Ratio'], row['Free Cash Flow per Share']] if x > 0])

    if positive_criteria >= 3:
        decision = "It is advisable to invest in " + row['Company'] + "\nReasons:\n" + ",\n".join(reasons)
    else:
        decision = "It is not advisable to invest in " + row['Company'] + "\nReasons:\n" + ",\n".join(reasons)
    
    return decision


# Function to extract company name and year explicitly from the user question
import string
def extract_company_and_year(sentence):
    # Process the sentence using SpaCy
    doc = nlp(sentence)
    # Extract company name
    #companies = [ent.text.upper() for ent in doc.ents if ent.label_ == "ORG" or "GPE"]
    companies = [ent.text.upper() for ent in doc.ents if ent.label_ in ["ORG", "GPE","NORP","PRODUCT"] and ent.label_ != "DATE"]
    years = extract_and_year(sentence)
    replaced_sentence = ""
    for token in doc:
        if token.text.upper() in companies:
            replaced_sentence += "ORG "
        elif token.text.upper() in years:
            replaced_sentence += "DATE " 
        else:
            replaced_sentence += token.text + " "
    
    #print("Replaced Sentence:")
    #print(replaced_sentence)
    #for ent in doc.ents:
     #   print("text",ent.text)
    #    print("label",ent.label_)
    return companies, replaced_sentence

# How many companies Available in data
def list_company(df):
    # Remove duplicate company names from the 'Company Name' column
    df['Companys'] = df['Company'].drop_duplicates(keep='first').reset_index(drop=True)
    unique_companies = ', '.join([company for company in df['Companys'].astype(str).tolist() if company != 'nan'])
    return f"\nThis is the list of companies which is avialable in out dataset: {unique_companies}"

# to get Current dat and time:
def current_date_time():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

# Function to extract company name and year explicitly from the user question
def extract_and_year(sentence):
    # Process the sentence using SpaCy
    doc = nlp(sentence)
    # Extract year and int(token.text) in available_details['Year']
    years = [token.text for token in doc if token.text.isdigit()]
    return  years


import time
def simulate_typing(answer):
    for char in answer:
        print(char, end='', flush=True)
        time.sleep(0.08)  # Adjust the delay (in seconds) as needed
    print()  # Move to the next line after the full answer is printed


def fun_bot(user_question):
#while True:
    response_text =""
    # Get a question from the user
    #user_question = input("USER: ")
    company_name, replaced_sentence = extract_company_and_year(user_question)
    #print(company_name)
    year_name = extract_and_year(user_question)
    #print(year_name)
    question, location, intent  = Cosine_distance(replaced_sentence)
    
    print(location)
    # Check if the user wants to exit
    if user_question.lower() == "bye":
        print("Goodbye!")
        
      
    else:   
        # Extract company name from question
        company_name, replaced_sentence = extract_company_and_year(user_question)
        #print(company_name)
        # Extract year from question
        year_name = extract_and_year(user_question)
        #print(year_name)
        # calling the fun_details function to extrect the information from dataset
        if location == "fun_detail":
            result = fun_detail(company_name, year_name, intent)
            return result
        
        # calling fun-the linear_predict
        elif location == "fun_predict":
            if not company_name:
                return "Can you please provide your query with the company name?"
            # Filter the DataFrame based on the company name
            filtered_df = df[df['Company'].str.upper() == company_name[0]]
            #print(filtered_df)
            if filtered_df.empty:
                company_name_str = ', '.join([name.title() for name in company_name])
                return f"The {company_name_str} company is not available in our database. You have to select from our company list."
            else:
                future_years, predicted_values, image_base64 = linear_regression_and_plot(intent, company_name)
                st.image(f"data:image/png;base64,{image_base64}")
                fu_years = [item for sublist in future_years for item in sublist]
                predicted_values = [round(value, 2) for value in predicted_values]
                result =  f"The predicted {intent} for the next 5 years shows a trend with projected values as follows: {fu_years[0]} = {predicted_values[0]}, {fu_years[1]} = {predicted_values[1]}, {fu_years[2]} = {predicted_values[2]}, {fu_years[3]} = {predicted_values[4]}, {fu_years[4]} = {predicted_values[4]}. All the financial terms are in millions of USD other than the ratios." 
                return result            
            
        elif location == "fun_comparative":
            if not company_name:
                return "Can you please provide your query with the company name?"
            
            for company in company_name:
                
                # Filter data for the specific company and financial term
                company_data = df[df['Company'].str.upper() == company]
                if company_data.empty:
                #company_name_str = ', '.join([name.title() for name in company])
                    return f"The {company} company is not available in our database. You have to select from our company list."
            
            else:
                image_base64, result  =  comparative_analysis(company_name, intent)
                st.image(f"data:image/png;base64,{image_base64}")
                return result
        
        # calling stock_valuation function
        elif location == "fun_stock":
            response = stock_valuation(company_name, year_name)
            return response
        
        # calling risk
        elif location == "fun_risk":
            response = financial_risk_assessment(company_name, year_name)
            return response
        
        # Calling Capital Budgeting
        elif location == "fun_capital":
            response = perform_capital_budgeting_analysis(company_name, year_name)
            return response
        
        # Calling Should I Invest
        elif location == "fun_invest":
            response = should_invest(company_name)
            return response
        #to get date and time 
        elif location == "fun_time":
            response = current_date_time()
            return response
        
        # to get list of companies
        elif location =="list_company":
            response = list_company(df)
            return response
        
        else:
            return str(location)
            '''for char in str(location):
                print(char, end='', flush=True)
                time.sleep(0.05)
            print()'''





# Example usage

